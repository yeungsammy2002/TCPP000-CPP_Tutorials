# Section 04 - Compiler Generated Functions

We're going to talk about 4 methods that could be **generated by C++ compiler** if you don't declare them by yourself:
1. **Copy Constructor**
2. **Copy Assignment Operator**
3. **Destructor**
4. **Default Constructor**

There is an addition rule about ***default constructor***. It will be generated only if there is no constructor declared at all.


Suppose we write a class `Dog` with **empty definition**:
```
class Dog {};
```

The class `Dog` is equivalent to a class like this. This compiler will filling the 4 methods for us since we don't have them define:
```
class Dog {
public:
    Dog(const Dog& rhs) { ... };                // Copy constructor

    Dog& operator=(const Dog& rhs) { ... };     // Copy assignment operator

    Dog() { ... };                              // Default constructor

    ~Dog() { ... };                             // Destructor
}
```
You imagine that the compiler generated methods are empty methods that doing nothing. For this particular case, they are doing nothing because the `Dog` class is so trivial but for any real world class. They will not be empty, they'll do their jobs.

These are the things that the compiler generated methods will do:
- The ***copy constructor*** will do a **member by member initialization**. It will use the members from **right hand side `Dog` object called `rhs`** to initialize every member of `this` object.

- The ***copy assignment operator*** will do a **member by member copying**, and it will copy the members from **constant right hand side `Dog` object** called `rhs` to `this` `Dog` object.

- The ***default constructor*** will **call *base class's default constructor* and the *data member's default constructor***.

- The ***destructor*** is doing the opposite. It will **call the *base class's destructor* and the *data member's destructor***.

Now you may want to ask a question. What if the compiler generated method is unable to do the job they are supposed to do? For example, the ***copy assignment operator*** will do a member by member copying, what if one of members is a `const` or a reference? Remember that `const` and reference they cannot be copied. They can only be initialized, then what does the compiler do? **The compiler will simply do not generator this copy assignment function.**

Similarly, for a `Dog`'s default constructor, what if the base class doesn't have a ***default constructor***. This `Dog() { ... }` method will not be generated.

For destructor, every `class` have a ***destructor*** so it should be no problem call the ***base class destructor*** and the ***data member destructor***, right? Not exactly, what if the ***base class destructor*** is not `public`, it's a `private` destructor, then this `~Dog() { ... }` method cannot be generated.

So the compiler generated methods sometimes are really handy to use, but you need to keep these things if you are relying on the compiler to generate these methods for you.

Note that all the compiler generated method are ***public*** and ***inline***. **They are generated only if they are needed**, that means if they are not used at all in the function with other functions, then they will not be generated, even if the compiler is capable of generating them.

Now let's look at a less trivial class `Dog`. The `Dog` has a `m_name`, which is the name of the `Dog` and it is a string. And the `Dog` constructor takes a `name` as a parameter and the default name is `"Bob"`. And the `Dog` has a destructor. In the `main()` function, I create `dog1` with the name `"Henry"`, and then I create `dog2`, and then assign `dog1` to `dog2`:
```
class Dog {
public:
    std::string m_name;

    Dog(std::string name = "Bob") {
        m_name = name;
        std::cout << name << " is born." << std::endl;
    }

    ~Dog() {
        std::cout << m_name << " is destroyed.\n" << std::endl;
    }
};

int main() {
    Dog dog1("Henry");
    Dog dog2;
    dog2 = dog1;
}
```

The output of this simple program is here. The reason that `Henry is destroyed` twice is because `dog2` was created at `"Bob"`, and the destroyed as `"Henry"` because `dog1` is assinged to `dog2`:
```
Henry is born.
Bob is born.
Henry is destroyed.
Henry is destroyed.
```

Let's examine what methods are generated by compiler in this particular example, 