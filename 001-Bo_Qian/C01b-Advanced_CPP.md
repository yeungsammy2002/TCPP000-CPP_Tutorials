# Section 04 - Compiler Generated Functions

We're going to talk about 4 methods that could be **generated by C++ compiler** if you don't declare them by yourself:
1. **Copy Constructor**
2. **Copy Assignment Operator**
3. **Destructor**
4. **Default Constructor**

There is an addition rule about ***default constructor***. It will be generated only if there is no constructor declared at all.


Suppose we write a class `Dog` with **empty definition**:
```
class Dog {};
```

The class `Dog` is equivalent to a class like this. This compiler will filling the 4 methods for us since we don't have them define:
```
class Dog {
public:
    Dog(const Dog& rhs) { ... };                // Copy constructor

    Dog& operator=(const Dog& rhs) { ... };     // Copy assignment operator

    Dog() { ... };                              // Default constructor

    ~Dog() { ... };                             // Destructor
}
```
You imagine that the compiler generated methods are empty methods that doing nothing. For this particular case, they are doing nothing because the `Dog` class is so trivial but for any real world class. They will not be empty, they'll do their jobs.

These are the things that the compiler generated methods will do:
- The ***copy constructor*** will do a **member by member initialization**. It will use the members from **right hand side `Dog` object called `rhs`** to initialize every member of `this` object.

- The ***copy assignment operator*** will do a **member by member copying**, and it will copy the members from **constant right hand side `Dog` object** called `rhs` to `this` `Dog` object.

- The ***default constructor*** will **call *base class's default constructor* and the *data member's default constructor***.

- The ***destructor*** is doing the opposite. It will **call the *base class's destructor* and the *data member's destructor***.

Now you may want to ask a question. What if the compiler generated method is unable to do the job they are supposed to do? For example, the ***copy assignment operator*** will do a member by member copying, what if one of members is a `const` or a reference? Remember that `const` and reference they cannot be copied. They can only be initialized, then what does the compiler do? **The compiler will simply do not generator this copy assignment function.**

Similarly, for a `Dog`'s default constructor, what if the base class doesn't have a ***default constructor***. This `Dog() { ... }` method will not be generated.

For destructor, every `class` have a ***destructor*** so it should be no problem call the ***base class destructor*** and the ***data member destructor***, right? Not exactly, what if the ***base class destructor*** is not `public`, it's a `private` destructor, then this `~Dog() { ... }` method cannot be generated.

So the compiler generated methods sometimes are really handy to use, but you need to keep these things if you are relying on the compiler to generate these methods for you.

Note that all the compiler generated method are ***public*** and ***inline***. **They are generated only if they are needed**, that means if they are not used at all in the function with other functions, then they will not be generated, even if the compiler is capable of generating them.


### How Does Compiler Generated Methods Works
Now let's look at a less trivial class `Dog`. The `Dog` has a `m_name`, which is the name of the `Dog` and it is a string. And the `Dog` constructor takes a `name` as a parameter and the default name is `"Bob"`. And the `Dog` has a destructor. In the `main()` function, I create `dog1` with the name `"Henry"`, and then I create `dog2`, and then assign `dog1` to `dog2`:
```
class Dog {
public:
    std::string m_name;

    Dog(std::string name = "Bob") {
        m_name = name;
        std::cout << name << " is born." << std::endl;
    }

    ~Dog() {
        std::cout << m_name << " is destroyed.\n" << std::endl;
    }
};

int main() {
    Dog dog1("Henry");
    Dog dog2;
    dog2 = dog1;
}
```

The output of this simple program is here. The reason that `Henry is destroyed` twice is because `dog2` was created at `"Bob"`, and the destroyed as `"Henry"` because `dog1` is assinged to `dog2`:
```
Henry is born.
Bob is born.
Henry is destroyed.
Henry is destroyed.
```

Let's examine what methods are generated by compiler in this particular example.
- Is the ***copy constructor*** generated by the compiler? No, because the ***copy constructor*** is not used in our `main()` function, so it will not be generated.
- Is the ***copy assignment operator*** generated by the compiler? Yes, we use copy assignment operator over here `dog2 = dog1`, and our `Dog` does not have a ***copy assignment operator*** defined. So the compiler will gladly generate that function for us.
- ***Destructor*** is always be used, but `Dog` already have a destructor defined. The compiler does not need to generate one for us.
- The ***default constructor*** is used over here `Dog dog2`, and `Dog` already defined a default constructor over here `Dog(std::string name = "Bob") { ... }`. **Many people have the concept that the *default constructor* is a constructor that has no parameter, that is a wrong. A *default constructor* is a constructor that can work without any parameter. So `Dog(std::string name = "Bob") { ... }` is our *default constructor***. So the compiler will **NOT** generated a ***default constructor*** for us, because we already have a ***default constructor***.


### Problem of Using Reference as `class` Attribute
Suppose I change the `m_name` member from **a string** to **a reference to a string**. Now what will happen to this code:
```
class Dog {
public:
    std::string& m_name;                // `m_name` becomes reference

    Dog(std::string name = "Bob") {
        m_name = name;
        std::cout << name << " is born." << std::endl;
    }

    ~Dog() {
        std::cout << m_name << " is destroyed.\n" << std::endl;
    }
};

int main() {
    Dog dog1("Henry");
    Dog dog2;
    dog2 = dog1;            // *copy assignment operator used
}
```
This code will no longer compile because **\*here** we are using a ***copy assignment operator*** that's generated by compiler. And then the ***compiler generated copy assignment operator*** that is a **member by member copy**. Since the `Dog` has a member, which is a reference, this `m_name` cannot be copied. So the compiler will not generate this operator for us, this code will not compile.

Another thing about this example is this kind of class cannot be used with the standard library container, because standard library container requires the **"containee"** to be **copy assignable** and **"copy constructible"**. So this is our trouble maker:
```
class Dog {
public:
    std::string& m_name;
    ...
};
```


### Problem of Missing Default Constructor in Member `class`
Let's look at our second example. We have a new class `Collar`. And the `Dog` have the data member `m_collar`, which is of type `Collar`. And in the `main()` function, I create a `Dog` object called `dog1`. What do you think the output of this program is:
```
class Collar {
public:
    Collar(std::string color) {
        std::cout << " collar is born.\n";
    }
};

class Dog {
    Collar m_collar;
};

int main() {
    Dog dog1;
}
```
This code will not compile, it will give us a compiler error that says `no matching function for call to 'Dog::Dog()'`. When I create `dog1`, I'm calling the **`Dog`'s default constructor** for `dog1`. And since my `Dog` doesn't have a ***default constructor***, the compiler will try to create a default constructor for us. And we know that the compiler generated a ***default constructor*** will call the data member's default constructor. In this case, we'll call **`m_collar`'s default constructor**. However, `Collar` doesn't have a ***default constructor*** either. So the compiler will try to generate the default constructor for `Collar` first. Since `Collar` already have a constructor that takes a ***string* parameter**, the compiler is not able to generate a ***default constructor*** for `Collar`. As a result, the compiler is not able to generate a ***default constructor*** for `Dog` either. That is why we got this message `no matching function for call to 'Dog::Dog()'` and then the candidates are the **`Dog`'s copy constructor** (`candidates are: Dog::Dog(const Dog&)`). We know that ***copy constructor*** is second constructor that compiler generates.

So if we remove the parameter for `Collar`'s constructor, then this code will compile, and the output will be ` collar is born.`:
```
class Collar {
public:
    Collar() {
        std::cout << " collar is born.\n";
    }
};
...
```

Now let's add a second data member `std::string& m_name` for `Dog`:
```
...
class Dog {
    Collar m_collar;
    std::string& m_name;
};
...
```
If you remember from previous example that a **reference data member** in the class will prevent the compiler from generating ***copy assignment operator*** for the `class`. In this example, we are only using the ***default constructor***. So we should be fine, right? Not exactly. The compiler generated default constructor will call the default constructor for the data member of the `Dog`. That is good. However, what the default constructor doesn't do is to initialize the data members for the `Dog`. So in this case, `m_name` is constructed but not initialized. And we know that ***C++ standard*** requires that all reference need to be initialized because reference cannot be reassigned, so only way to assign a variable to a reference is through ***initialization***, because `m_name` is not initialized. So this code will not compile.


### Define Default Constructor using `default`
Finally, there's an update in ***C++11***. There's a new way to define the default constructor. It is done by this:
```
class Dog {
public:
    Dog() = default;
    Dog(std::string name) { ... }
};
```
This gives me a way to use the compiler generated constructor even though I have defined other constructors already. So this should be a very handy feature.




# Section 05 - Disallow Functions
Last time we've talked about the four methods that the compiler automatically generated for us if we don't create them ourselves. The ***copy constructor***, the ***copy assignement operator***, the ***destructor*** and the ***default constructor***. That is nice. It save us some effort and time to create them. However, the ***compiler generated methods*** are not always useful. And sometimes, they are even dangerous to use.

For example, we have a class `OpenFile`, which represent a file being opened. Since the compiler will automatically generated the default constructor for us. I can do `OpenFile f`, and this will call the compiler generated default method:
```
class OpenFile {
};

int main() {
    OpenFile f;
}
```
If you run it, it can run successfully from begin to end although it does nothing.

In this case, the ***compiler generated default constructor*** is useless to us, because in order to open a file, we at least need a file name. Say I don't want my client to use my `OpenFile` this way, and I want to disallow that. How can I do it?

For default constructor, it is actually easy. As I define a constructor that takes any parameters, then the compiler will not generate the default constructor for me. So here I create another constructor that takes a string of `filename`, and then it prints some messages:
```
class OpenFile {
public:
    OpenFile(std::string filename) {
        std::cout << "Open a file " << filename << std::endl;
    }
};
```
If you run it, you'll see the compiler failed. That is because no match function for call to the default constructor (`no match function for call to 'OpenFile::OpenFile()'`). So the default constructor is not there anymore.

Now in order to create our `OpenFile` object, I need to provide a parameter, let's call it `std::string("Bo_file")`. And then run it:
```
int main() {
    OpenFile f(std::string("Bo_file"));
}
```
If you run it, it will compile without error:
```
Open a file Bo_file
```
In this case, the compiler generated method is just useless, but it doesn't harm us anyway. But sometimes, the compiler generated method could be dangerous to use. For example, say now I have open `"Bo_file"` for writing with `f`. And then I create another `OpenFile` object called `f2`, which is copy constructed from `f`. This will call the ***compiler generated copy constructor*** for `f2`. And `f2` will also write to `"Bo_file"`:
```
int main() {
    OpenFile f(std::string("Bo_file"));

    OpenFile f2(f);
}
```
Now we have both `f` and `f2` writing to `"Bo_file"` at the same time. So the result will be pretty messy. So I want to disallow the ***copy constructor*** from being use, what can I do?

If you are using ***C++11*** already, it is pretty easy. All you need to do is to make the ***copy constructor*** to be a ***deleted method*** by using `delete` keyword:
```
class OpenFile {
public:
    OpenFile(std::string filename) {
        std::cout << "Open a file " << filename << std::endl;
    }
    OpenFile(OpenFile& rhs) = delete;
};

int main() {
    OpenFile f(std::string("Bo_file"));

    OpenFile f2(f);                     // Compiler error
}
```
If you run it, the compile failed because the deleted method is being used.

If you're using  ***C++03***, all you need to do is make the ***copy constructor*** a `private` method and don't define the method:
```
class OpenFile {
public:
    OpenFile(std::string filename) {
        std::cout << "Open a file " << filename << std::endl;
    }
private:
    OpenFile(OpenFile& rhs);
};

int main() {
    OpenFile f(std::string("Bo_file"));

    OpenFile f2(f);                     // Compiler error
}
```
If you run it, the compile failed because the ***copy constructor method*** is `private`.

Some of you may be clever enough to say *"This is not enough, `OpenFile` member method can still use the copy constructor"*. Say it has a method called `g()` and `g()` create another open file `f2` from `f`:
```
class OpenFile {
public:
    OpenFile(std::string filename) {
        std::cout << "Open a file " << filename << std::endl;
    }
    g(OpenFiles& f) {
        OpenFile f2(f);
    }
private:
    OpenFile(OpenFile& rhs);
};
```
This will work, right? If you run it, it will still failed, but now it failed with a message `error: ISO C++ forbids declaration of 'g' with no type`. Although method `g()` can access the ***copy constructor***, since we only have declared the ***copy constructor***, we have not define it. So method `g()` cannot find the body of the ***copy constructor***. So as a result, nobody can use the ***copy constructor*** anymore. And we can also use the same method to disable the ***copy assignment operator***:
```
class OpenFile {
public:
    OpenFile(std::string filename) {
        std::cout << "Open a file " << filename << std::endl;
    }
    g(OpenFile& f) {
        OpenFile f2(f);
    }
private:
    OpenFile(OpenFile& rhs);
    OpenFile& operator=(const OpenFile& rhs);
};
```
This approach can be used to disable any method, i.e. the default constructor, the destructor, or say the `OpenFile` has inherited a method called `writeLine()` and we don't want the `OpenFile` to use that method, you can use this method to turn that method off.
```
class OpenFile {
public:
    OpenFile(std::string filename) {
        std::cout << "Open a file " << filename << std::endl;
    }
    g(OpenFile& f) {
        OpenFile f2(f);
    }
private:
    OpenFile(OpenFile& rhs);
    OpenFile& operator=(const OpenFile& rhs);
    void writeLine(std::string str);
};
```

Let's turn off the ***destructor*** by making it to be `private`, and we have not defined it so nobody can use the `OpenFile` destructor anymore:
```
class OpenFile {
    ...
private:
    ~OpenFile();                                // destructor
};
```
Is this a good idea? Apparently **NOT**. An object must be destructed one way or another, otherwise some resource is doomed to be leaked. So we have to give a body to the ***destructor***:
```
    ~OpenFile() {
        std::cout << "`OpenFile` destructed." << std::endl;
    }
```

However, sometimes it does make sense to have a `private` destructor. Let's the following example. Suppose we only have a ***constructor*** and a ***destructor***:
```
class OpenFile {
public:
    OpenFile(std::string filename) {
        std::cout << "Open a file " << filename << std::endl;
    }
private:
    ~OpenFile() {
        std::cout << "`OpenFile` destructed." << std::endl;
    }
};

int main() {
    OpenFile f(std::string("Bo_file"));
}
```
If we compile the program, it will fail because the ***destructor*** is `private` since the `OpenFile` object `f` is stored on ***stack***. Once the `f` is out of scope, the stack unwind, and `f` will be destructed. And since `main()` function has no access to the `private` method of destructor of `OpenFile`, this will not compile. So this kind of file is invincible. It can not be destroyed by anyone else except itself and its `friend`s.

This kind of mechanism sometimes are used by ***reference counting shared pointers***. A ***reference counting shared pointer*** counts the number of pointers that points to itself. And once that count reached `0`, it commits suicide. In our example of `OpenFile` since it doesn't commit suicide and it doesn't have `friend`s, so we have to provide a public inteface. Let's call it `destroyMe()` to delete `this` object. And in the `main()` function we can call `f.destroyMe()` to destroy the `OpenFile` object `f`:
```
class OpenFile {
public:
    OpenFile(std::string filename) {
        std::cout << "Open a file " << filename << std::endl;
    }
    void destroyMe() {
        delete this;
    }
private:
    ~OpenFile() {
        std::cout << "`OpenFile` destructed." << std::endl;
    }
};

int main() {
    OpenFile f(std::string("Bo_file"));
    f.destroyMe();
}
```
If you run it, it still fail. It still reports the same error, the `OpenFile` destructor is `private`. Since `f` is stored on ***stack***, even though we have called `f.destroyMe()` to destroy the `f`, when the stack unwind, `f` will be destroyed again. So the ***private destructor*** will be invoked anyway. How can we an object like `OpenFile`, which has a ***private destructor***. We could store `f` on ***stack***, and then call `f->destroyMe()`.
```
...
int main() {
    OpenFile* f = new OpenFile(std::string("Bo_file"));
    f->destroyMe();
}
```
Now let's run it, the program compiled and run successfully on the console:
```
`OpenFile` destructed.
```

So the conclusion is class like `OpenFile`, which has a ***private destructor*** can only be stored on ***heap***. It cannot be stored on ***stack***. This sometimes can be useful in the ***embedded programming*** where the ***stack size*** is small and the people often time get a ***stack overflow***. You could let the heavy weight classes to have ***private destructor*** so that they can only be stored on the ***heap***. You kind of enforced that they heavy weight objects not to be stored on the ***stack***.


### Summary of Disallowing Functions
1. For ***C++11***, you can always use the keyword `delete` to delete the method.
2. For ***C++03***, you can declare the method to be `private`, but not define it.
3. ***Private destructor*** can be used to force the object not to be stored on ***stack***.




# Section 06 - Virtual Destructor and Smart Destructor
We'll talk about using ***vitual destructor*** in ***polymorphic base classes***. 

Let's look at our example. We have a class `Dog`, and `Dog` destructor prints out `"Dog destroyed"`. `YelloDog` derived from `Dog` and `YelloDog` destructor prints out `"Yellow dog destroyed."`. And in the class `DogFactory`, we are using a factory design pattern. We use the `DogFactory` class to be a centralized place of creating `Dog` objects. And we have a `static` method to create `YellowDog` and then return it as a `Dog` pointer. And it is also has other methods to create other types of `Dog` objects. In the `main()` function, I assign the return value of `DogFactory::createYellowDog()` to a `Dog` pointer `pd`. And after I have done something with `pd`. Eventually, I delete `pd`:
```
class Dog {
public:
    ~Dog() {
        std::cout << "Dog destroyed" << std::endl;
    }
};

class YellowDog : public Dog {
public:
    ~YelloDog() {
        std::cout << "Yello dog destroyed." << std::endl;
    }
};

class DogFactory {
public:
    static Dog* createYellowDog() {
        return (new YellowDog());
        //... create other dogs
    }
};

int main() {
    Dog* pd = DogFactory::createYellowDog();
    //... Do something with pd

    delete pd;
}
```
Let's run the program, and here is the output on the console:
```
Dog Destroyed
```
As you can see, when `pd` gets deleted, only the `Dog`'s destructor gets called. That is very bad, because we have created a `YellowDog` object, and at the end only part of the `YellowDog` object is destructed. 

We have to make sure that the `YellowDog`'s own destructor also needs to be invoked. This is why we need a `virtual` destructor for the base classes:
```
class Dog {
public:
    virtual ~Dog() {
        std::cout << "Dog destroyed" << std::endl;
    }
};
```
Now if we run the program, both `YellowDog` destructor and `Dog` destructor invoked:
```
Yellow dog destroyed.
Dog destroyed.
```
So the conclusion we are getting from this example is if a class is meant to be used in a polymorphical way, such as in this case we are creating a `YelloDog`, and then casted it into a `Dog`'s pointer. Then the base class must have a ***virtual destructor*** to ensure the destructor is invoked appropriately.

If a class has any sort of virtual method like `bark()` method, it is mostly likely that this class will be used polymorphically, which means mostly likely it will need a ***virtual destructor***:
```
class Dog {
public:
    virtual ~Dog() {
        std::cout << "Dog destroyed" << std::endl;
    }
    virtual void bark() {}
};
```
If for some reason, you really don't want to have a ***virtual destructor***, then there is a second way to do it by creating a shared pointer of `YellowDog` using `std::shared_ptr` class. In this case, I have created a shared pointer of `YellowDog`, and then casted into a shared pointer of `Dog`. In the `main()` function, I don't need to delete `pd` anymore, because the shared pointer will be responsible to delete the object. And we don't even the virtual destructor of `Dog` class:
```
class Dog {
public:
    ~Dog() {                                            // no `virtual`
        std::cout << "Dog destroyed" << std::endl;
    }
    virtual void bark() {}
};
...
class DogFactory {
public:
    static shared_ptr<Dog> createYellowDog() {
        return shared_ptr<YellowDog>(new YellowDog());
        //... create other dogs
    }
};

int main() {
    shared_ptr<Dog> pd = DogFactory::createYellowDog();
}
```
Let's run the program again, and here is the output on the console:
```
Yellow dog destroyed.
Dog destroyed.
```
As you can see, both `YellowDog` and `Dog` destructors are invoked.

Note that you can only use the shared pointer to perform this kind of magic. If you are using an ***unique pointer***, it won't do the job. Unique pointer will only invoke the `Dog`'s destructor.

This last thing I want to point out is **all the classes in *STL* have no virtual destructor. So you need to be very careful when you are inheriting from them.** One thing you can do is try to use shared pointer as much as possible for the classes that is derived from the ***STL*** classes.